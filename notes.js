Find.creeps == all creeps
Find.creeps.byMemory(value, key)
Find.flags.byColor(value)
Find.flags.byName(value)
Find.sources == all sources
Find.sources.stores?...
// At first this layout sounded nice, but really it's just flattening the utility... hm...
filter(Game.creeps, )
// God even worse as we already have the lodash doing this
// Hmm, for the small ones it looks obsolete what I have, but the large ones make it look good...
Find.structures.lowEnergy();
Find.stores == all stores // This is slightly different and could be useful
Find.stores.lowEnergy();
Find.stores.nearest(pos, distance); // As stores is inheriting from Find, we will always have nearest available... distance would be rooms away I guess
// We're just trying to find objects here, so we'd be doing calculations outside somewhere else
// Calculations could be done inside utility.js or something...
// Okay, got default functions working and I know the layout of how I want to make my calls... I should probably adjust to a kind of Find.stores()... hmm
// I don't think I should really be doing Find.stores()... also I probably shouldn't be doing a default function, I should just do all() instead...
// The next problem, is how do I call the inherited functions for the children... I will probably just be requiring Find in everything, which would then require stuff needed...
// I can't require from a child in this case... unless I split it out and used a different naming convention, but I don't want to? What I do here will affect how I handle roles too...
// 3 options, I could somehow include root in this object, I could split out objects and call individually, or I could look into importing specially with ES6 (maybe though)
// I think splitting out might be best... problem I guess is naming things?
FindCreeps.all(), RoleMiner.run()... 
// I might end up doing something similar for utility, which I've tried before... UtilityCreeps.findByRole() circle dependency
// I could create a separate object which has the global functions in it... this object is then just a wrapper...
// Finder.byMemory... Find.creeps.byMemory... hmm not pretty... although I guess Find could include Finder's functions too...
// I should probably do it the proper way, with class/object inheritence and not fudge it to make it look how I want? I suppose it doesn't matter too much...
// Alright, I'll fudge it with a global finder and import for all of them :P
// Hmm no, I don't want to fudge it... 
// Looking at another way...
Creeps.find.all()
Creeps.find.byMemory();
Creeps.find.nearest();
Creeps.calc.currentRoles();
Creeps.calc.expected();
Stores.find.all();
Stores.find.byMemory();
// This way is kind of nice, I keep things in their own components folders (creep/world/etc)
// For each sub object (such as .find) I can import a global class and use those functions
// The reason why I like Find.foo is because it's working with plurals... Creep, Room, etc... are ingame objects so I can't do this...
Creep.calc.bodyRole();
// I'd have to do instead modify the existing Object... I suppose that isn't so bad? I could in some cases just modify the object if it exists...
Creep.remember.source();
// I think to do this, I'd have to check if the object exists, if not create a new object... then just continue with the prototype stuff
Spawns.find.nearest(pos); // pos has name of the room, and the x/y position...
Spawn.calc.totalEnergy
Spawn.calc.isRegenerating()
// Game
// Memory
// ConstructionSite
// Creep
// Energy
// Exit
// Flag
// Room
// RoomPosition
// Source
// Spawn
// Structure
// Can use global.Creeps to create my own global objects with their own global properties...
// So! I check if the object exists, if not, I create it! then I simply add in my custom stuff...
// Considering now, how to have Game.creeps in Creeps.calc.currentRoles... 
// My current knowledge means I have to do a call to Game.creeps, but extending the object Creep doesn't make me do that... it gives me creep as "this"
// I need to get the scope of this as Game.creeps for the object Creeps...
// Array is just an object type... you can do new Array(array) and it'll create you an object which value is the array...
// I need to do the same things for Creeps... but it's not working when I try to set it to this...
// Multiple inheritence is possible and I want to use it...
// However, I'm getting a bit hung up on plurals I think... 
Creeps.find.byId() // For example would just return 1 creep... 
Creep.find.byId() // Makes more sense, but then it wouldn't work when I do
Creep.find.all() //
// I suppose I could just have some find on Creep, and some find on Creeps... this way I know what they return (either array or single object)
// Still need to figure out how to make Creeps the Game.creeps object/array and then extend it with functions and properties

Creeps.getBy...(); // 
Creeps.aboutBodyRoles(); // I don't like it :P
About.Creeps.bodyRoles();
Filter.Creeps.byMemory();
Filter.Flags.byName();
About.Creep.
// No see the problem with this is I can't call it on creep... creep.??... I have to pass in the creep every time, I don't wannaaa
//I could do a mix? I can still create classes with methods...
Creep.getBodyRole();
Creeps.getBodyRoles();
//Then I can just do 
Filter.byMemory(targets, key, value);
Creep.getCurrentTarget();
Creep.getCurrentPath();
Creep.setCurrentTarget();
Creep.mine();
Creep.protect();
//Creep.getNearestTarget(targets); // This could get the nearest target to the creep... might not need since we should probably be using Filter
// I'd do the same for towers too by just inheriting the Targeting module
Tower.getCurrentTarget();
//What I don't like is that this stuff isn't obviously inherited... 
Creeps.getTotalExpected();
// I need to think of a way to implement caching when it suits... like Creep.setCurrentPath... I suppose I get the value for the path, then call...
Cache.set(key, value, age); // Will update if exists? using age to say how long the value should be kept for...
Cache.get(key, age?); // Could use age again here to control how fresh we want the value to be... 
Cache.clear(); // Removing anything that's too old in this tick
Filter.byNearest(targets, target); // This could get the nearest target to the target...
Spawn.queue();
// Hmm... should study this...
creep.memory.something
creep.carry.energy
// These are all looking at different parts of the creep... so creep's memory, creep's carry... 
// In this case, I wasn't so wrong with creep.target, or creep.about... since it's consistent!
// I can't use creep.prop, since the value gets lost... I can still use methods though as they'll just work with the Cache/memory
// Cache isn't quite right perhaps... since I want to store on the memory for the creeps themselves...
// Perhaps I can look into doing a new Cache object, and adding that to creep... Creep.cache.set, Creep.cache.get...
// I still kind of lose the scope of "this" though... 
// I could pass it into the constructor... new Something(this);... in constructor I can do this.outerscope = outerscope...
// Then I can just do a check in constructor... if outerscope === null... this.outerscope = this... then I can just call rest of the functions as normal... hmm... interesting...
// This does something similar -  http://stackoverflow.com/questions/10656119/javascript-get-reference-to-parent-object-class-from-event-handler
// It does it with objects though... I could probably just do the same after adding the object...
// object.cache.outerscope = this;... simple enough really
// Okay, we're going to carry on with the original plan then... atleast I've gained a better understanding of things (js and what to do with cache)
Creeps.find.byId();
Creeps.find.all(); // return this.outerscope?... hm, hard one really...
// Sigh, getting tricky with the all() bit... making it return itself is kind of okay I suppose... but really I should just be using Creeps[name] anyway...
// Also, I wouldn't do Creep.find.byId(), since I already have the creep...
// Consider Creep.memory.raa is a property of Memory, not a method... hmmm... however it is a child... so Creep.target.getCurrent() is still valid really
// Hmm, classes are all singular... if Creep.do.something... that's okay... but Creeps.do.something... not okay...
// var creep = this... creep.do.this
// var creeps = Creeps? Odd thing to do...
// Perhaps instead I should extend where it affects singular classes... like Creep.target.getCurrent()... creep.target.getCurrent()...
// However, to work with all the creeps, what? what do I doooo, sigh :P
Find.creep.byId();
Find.creeps.byRole();
Util.creeps.getBodyRole(); // This is okay, but then...
Util.creep.getBodyRole(); // This would make sense... but I want to do this on the creep object itself... creep.getBodyRole()...
Target.creep.getCurrent();
// This keeps it general purpose, and allows me to add on new managers when I need to easily...
Combat.squadron.make();
Combat.squadron.move();
// Although I could put it to this too...
creep.combat.move();
// Hmm, going round in circles a bit which is frustrating, but I should probably not make a class that is plural I know that much...
// creep is local, but creeps could be global?
// Affecting objects is all well and good, but what about when I need to do something unrelated to objects, like... trigger cache expiry...
creep.cache.expire() // Is what I'd have to do for every single object that has a cache I think?
creeps.cache.expire();
// But if I worked with objects separately, much like how the game has a Memory/PathFinder class...
Filter.byId(targets);
Filter.byNearest(targets, target);
// Perhaps this really is the best way to do things...
// It would be folly to use classes actually I think, since if there are private methods I can just avoid exposing them, and properties do not get stored
filter.byId(targets, id); // Would be best
wayfinder.getTarget(target);
wayfinder.getPath(from, to);
combat.escort(target);
combat.steal(target);
creep.defend(pos); // Actually since these are creep actions, they should belong to the Creep prototype... as much as I like the combat idea, I could just make it an object and include for tower too?
// Getting and moving to a source...
filter.byTile(targets/flags, 'source'); // Would be passing in the Game.flags I think?
filter.byMemory(targets/creeps, 'source.id', source.id); // Would return all of the sources currently occupied in the returned source list
// Need to get the inverted version of what is taken
filter.reject(targets/allsources, targets/takensources); // This would return a list of targets with free sources... _.reject(someArray, function(el) { return el.Name === "Kristian"; });
tasker.setSource(); // ??
creep.setSource();
creep.defend(); // Hmm, I like having a combat object though...
// I like thinking of the main.js file as HQ and the spawns as hubs
tasker.repair() // Would be my own flavour of repair calling creep.repair...
// Roles would still be viable...
creep.memory.busy = true // I'll just use whether it's busy in it's current role or not... I should probably change resetting it's role? instead just change the busy flag and look at that?
// At the end of all the checks, just make it move to idle I suppose...
spawner.queue(); // It would be nice to change spawner to have a queue
spawner.checkNeeds(); // This would be checking if we need anything spawned I guess? Checking flags etc...
// What would actually move out groups of creeps though?
// Probably the tasker? It would check what task needs fulfilling, what a creep was made for, and make it fulfill that role/task
// If squadron flag, then move there...

// We have...
// Filtering - filter
// Pathfinding - wayfinder
// Tasking - tasker
// Finder - find
// Roles
// Creep actions
// Spawning
// Dumper - for anything that doesn't fit I suppose to temporarily remain until I can think where to put it
// We could later...
// Autobuilding
// Caching - really I could do this now I just don't know where to add it...

// Okay I think this makes way more sense, since when we do creep.find.byId()... it doesn't make sense! we already have the creep, now we're making it find itself?
// However filter.something can apply to anything! :)

// Just pondering... how am I going to get hubs working... I want a hub to have it's own community of repairers and guards... a hub will be defined by it's spawn...
// I should probably save the origin.room value... then I could just calc distance for each creep?... something like...
filter.byDistance(Game.creeps, source, Config.distance.limit); // This could get all the creeps near the source...
// OR
filter.byDistance(sourceFlags, creep, Config.distance.limit); // This could get all the sources near the creep...
// Alternatively... I could save the hub name in the flag itself, that way I wouldn't need to calc distance
// I'm thinking of building something for the flags... something that would go through and set up their memory when I place them? hmm maybe overcomplicating things...

// Okay, inside of calc I have a bunch of things, these should be parts of prototypes for the most part...

// Hmm, still not sure how to handled getting a source for a creep...
// get creeps
// filter by source id
// reject them
// now have available sources
// can now send off to mine...
// The problem is that this is a lot of lines, just get the source... I should really have a way to reuse it all...
// Not only that, but I may want to be doing other calculations across plural objects that aren't in-game classes (like creeps)

// I don't think I can extend Game.creeps, unless I extend it every tick, since it's not a class it's an object
// Also the methods I'll be doing will be too specific to what they're being used on to make into general things like Filter has...
// What am I performing? I'm performing calculations, so I call it calc? Pahh

Creep.getBodyRole();
Game.creeps.getBodeRoles(); // Might be okay?
// The problem is I'd need to extend Game.creeps with every single tick...

// Perhaps I should try thinking about Room object instead...
// I've added Room.getVacantSource, except I'm not going to work with rooms anymore, I'm going to work with flags...
// In which case, how do I call getVacantSource? It doesn't really fit on the Game.flags object, even if it didn't expire after the first tick
// perhaps I should apply to a world object? world.sources.getVacant();... although it might fit better under find... find.vacantSource(creep);...
// hub... this is what I should be using!
// hub.getOriginCounts();... basically hub.getBodyRoles()... since I'm not caring about the world now, I'm caring about the hub when I want to spawn a creep, right?
// A problem may occur if I want to spawn a creep for another hub (since that hub may be too new/weak...)...
// However I can look at this later, since I can look for hub with most potential energy, or hub that is closest... or just hub with energy needed and sort by closest...
// On spawn, the creep would be assigned to that hub and start trying to work in that hub's area

// I need to go through and refactor hub, creep, and room... I will probably change how a few things work too in there...
// I also need to think about how the spawner is actually going to work...
// hub.getSpawner(), then I can just add methods to the prototype maybe? like queue? hmm...
// Really I don't want an autospawner class, I want a hub method managing it's hub... making spawn requests if it needs, same with checking for platoons and stuff...


// RENEWING
// Idea is that if we send over creeps to another spot, they might need renewing (if their body cost is greater than what hub can afford)
// Spawn = 150 creep... 33 ticks, 150 energy
// 600/3 = 200 ticks per renew
// 150/2.5/3 = 20 energy per renew
// Renew = 150 creep... 7 ticks (+ ticks to walk back), 140 energy 
// So basically this is a good idea... if creep cost > hubPoint capacity && ticks < 100, send it out for renew!... we should push to front of the queue too once in range...

// Not sure how to calculate whether or not to keep a squadron alive? how would I disband it after use... just remove the flag? hmm

// Hmm, browserify does get all my requires into 1 file, but Creeps likes to have main as it's own file that exports a loop

// Got everything compiling and now running in Screeps :D
// Just need to start adding in the stuff I need to now... should go with the manager route for now